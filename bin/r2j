#!/usr/bin/env bash
# ruby-hash-to-json
# Convert Ruby-style hash strings into valid JSON
# Version: 0.1.0

set -euo pipefail

PRETTY=false

usage() {
  cat <<'EOF'
ruby-hash-to-json v0.1.0
Convert Ruby-style hash strings into valid JSON.

USAGE:
  ruby-hash-to-json [-p|--pretty] [INPUT]
  echo "{:foo=>'bar'}" | ruby-hash-to-json -p

OPTIONS:
  -p, --pretty   Pretty print JSON (requires jq if installed)
  -h, --help     Show this help

NOTES:
- If jq is installed and -p is used, output will be styled via jq.
- INPUT may be a single-argument string; otherwise stdin is read.
EOF
}

# Parse args
input=""
while [[ $# -gt 0 ]]; do
  case "$1" in
    -p|--pretty) PRETTY=true; shift ;;
    -h|--help) usage; exit 0 ;;
    --) shift; break ;;
    -*)
      echo "Unknown option: $1" >&2
      usage
      exit 1
      ;;
    *)
      if [[ -z "$input" ]]; then
        input="$1"
      else
        echo "Unexpected argument: $1" >&2
        usage
        exit 1
      fi
      shift
      ;;
  esac
done

# Read input (from argument or stdin)
if [[ -n "${input:-}" ]]; then
  s="$input"
else
  s="$(cat)"
fi

# Ruby scalars → JSON
s=$(echo "$s" | sed -E 's/\\bnil\\b/null/g')
s=$(echo "$s" | sed -E 's/\\btrue\\b/true/g')
s=$(echo "$s" | sed -E 's/\\bfalse\\b/false/g')

# Single-quoted Ruby strings → JSON double quotes
s=$(echo "$s" | sed -E "s/'([^']*)'/\\"\\1\\"/g")

# Keys
s=$(echo "$s" | sed -E 's/([{,\\[])[[:space:]]*:"([^"]+)"[[:space:]]*=>/\\1"\\2":/g')
s=$(echo "$s" | sed -E 's/([{,\\[])[[:space:]]*:([a-zA-Z_][a-zA-Z0-9_]*)[[:space:]]*=>/\\1"\\2":/g')
s=$(echo "$s" | sed -E 's/([{,\\[])[[:space:]]*"([^"]+)"[[:space:]]*=>/\\1"\\2":/g')

# Remaining hash rockets → colons
s=$(echo "$s" | sed -E 's/=>/:/g')

# Symbol values
s=$(echo "$s" | sed -E 's/:\\s*:"([^"]+)"/: "\\1"/g')
s=$(echo "$s" | sed -E 's/:\\s*:([a-zA-Z_][a-zA-Z0-9_]*)/: "\\1"/g')

# Output
if $PRETTY && command -v jq >/dev/null 2>&1; then
  echo "$s" | jq .
else
  echo "$s"
fi